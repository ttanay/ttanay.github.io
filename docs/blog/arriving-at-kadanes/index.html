<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Arriving at Kadane's algorithm | Tanay Tummalapalli</title>
<meta name=title content="Arriving at Kadane's algorithm"><meta name=description content="I found the explanation of Kadane&rsquo;s algorithm on Wikipedia[1] too dense for a normie like me. So, I asked myself, if the algorithm were to be lost to the sands of time, how would I arrive at it naturally?
Kadane&rsquo;s algorithm is a solution to the maximum subarray problem.
What is the maximum subarray problem? We take help from Wikipedia here.
In computer science, the maximum sum subarray problem, also known as the maximum segment sum problem, is the task of finding a contiguous subarray with the largest sum, within a given one-dimensional array A[1&mldr;n] of numbers."><meta name=keywords content="study,algorithms,"><meta property="og:url" content="https://ttanay.github.io/blog/arriving-at-kadanes/"><meta property="og:site_name" content="Tanay Tummalapalli"><meta property="og:title" content="Arriving at Kadane's algorithm"><meta property="og:description" content="I found the explanation of Kadane’s algorithm on Wikipedia[1] too dense for a normie like me. So, I asked myself, if the algorithm were to be lost to the sands of time, how would I arrive at it naturally?
Kadane’s algorithm is a solution to the maximum subarray problem.
What is the maximum subarray problem? We take help from Wikipedia here.
In computer science, the maximum sum subarray problem, also known as the maximum segment sum problem, is the task of finding a contiguous subarray with the largest sum, within a given one-dimensional array A[1…n] of numbers."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-05-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-26T00:00:00+00:00"><meta property="article:tag" content="Study"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="Arriving at Kadane's algorithm"><meta name=twitter:description content="I found the explanation of Kadane’s algorithm on Wikipedia[1] too dense for a normie like me. So, I asked myself, if the algorithm were to be lost to the sands of time, how would I arrive at it naturally?
Kadane’s algorithm is a solution to the maximum subarray problem.
What is the maximum subarray problem? We take help from Wikipedia here.
In computer science, the maximum sum subarray problem, also known as the maximum segment sum problem, is the task of finding a contiguous subarray with the largest sum, within a given one-dimensional array A[1…n] of numbers."><meta itemprop=name content="Arriving at Kadane's algorithm"><meta itemprop=description content="I found the explanation of Kadane’s algorithm on Wikipedia[1] too dense for a normie like me. So, I asked myself, if the algorithm were to be lost to the sands of time, how would I arrive at it naturally?
Kadane’s algorithm is a solution to the maximum subarray problem.
What is the maximum subarray problem? We take help from Wikipedia here.
In computer science, the maximum sum subarray problem, also known as the maximum segment sum problem, is the task of finding a contiguous subarray with the largest sum, within a given one-dimensional array A[1…n] of numbers."><meta itemprop=datePublished content="2024-05-26T00:00:00+00:00"><meta itemprop=dateModified content="2024-05-26T00:00:00+00:00"><meta itemprop=wordCount content="440"><meta itemprop=keywords content="Study,Algorithms"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style></head><body><header><a href=/ class=title><h2>Tanay Tummalapalli</h2></a><nav><a href=/>Home</a>
<a href=/blog>Blog</a></nav></header><main><h1>Arriving at Kadane's algorithm</h1><p><i><time datetime=2024-05-26 pubdate>26 May, 2024</time></i></p><content><p>I found the explanation of Kadane&rsquo;s algorithm on Wikipedia[1] too dense for a normie like me. So, I asked myself, if the algorithm were to be lost to the sands of time, how would I arrive at it naturally?</p><p>Kadane&rsquo;s algorithm is a solution to the <strong>maximum subarray problem</strong>.</p><p>What is the <strong>maximum subarray problem</strong>? We take help from Wikipedia here.</p><blockquote><p>In <a href=https://en.wikipedia.org/wiki/Computer_science title="Computer science">computer science</a>, the <strong>maximum sum subarray problem</strong>, also known as the <strong>maximum segment sum problem</strong>, is the task of finding a contiguous subarray with the largest sum, within a given one-dimensional <a href=https://en.wikipedia.org/wiki/Array_data_structure title="Array data structure">array</a> A[1&mldr;n] of numbers.
For example, for the array of values [−2, 1, −3, 4, −1, 2, 1, −5, 4], the contiguous subarray with the largest sum is [4, −1, 2, 1], with sum 6.</p></blockquote><p>Try solving the <a href=https://leetcode.com/problems/maximum-subarray/>Leetcode problem</a>[2] for this.</p><p>A brute-force solution would simply enumerate all subarrays and check their sum.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;climits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxSubarraySum</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span> arr) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> max_sum <span style=color:#f92672>=</span> INT_MIN, subarr_sum;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> arr.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            subarr_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i; j <span style=color:#f92672>&lt;</span> arr.size(); j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                subarr_sum <span style=color:#f92672>+=</span> arr[j];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(subarr_sum <span style=color:#f92672>&gt;</span> max_sum)
</span></span><span style=display:flex><span>                    max_sum <span style=color:#f92672>=</span> subarr_sum;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> max_sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The time complexity for this is \(O(n^2)\). Terrible, I know!
But, this gives us some insight into the problem.</p><p><strong>Intuition</strong>: To calculate the contiguous subarray sum, we will need to calculate a running sum(<code>subarr_sum</code> in the example above).</p><p><strong>Observation</strong>:
Consider the same example \(A = [-6, 4, -2, -3]\).
The subarray sum between \(A[1..2] &lt; A[2]\).
When calculating the running sum, if the array element being considered happens
to be greater than the current running sum, we can conclude that current running
sum will not contribute towards the maximum subarray sum since the single element is already the maximum subarray sum so far.</p><p>To incorporate the observation, we reset the running sum to the current element each time <code>running_sum &lt; arr[i]</code>.</p><p>The algorithm then becomes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;climits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxSubarraySum</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span> arr) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> max_sum <span style=color:#f92672>=</span> INT_MIN, running_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> arr.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(running_sum <span style=color:#f92672>+</span> arr[i] <span style=color:#f92672>&lt;</span> arr[i])
</span></span><span style=display:flex><span>			running_sum <span style=color:#f92672>=</span> arr[i];
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>			running_sum <span style=color:#f92672>+=</span> arr[i];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span>(running_sum <span style=color:#f92672>&gt;</span> max_sum)
</span></span><span style=display:flex><span>			max_sum <span style=color:#f92672>=</span> running_sum;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> max_sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is gets us to \(O(n)\) time!</p><p>Making the code a little cleaner:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;climits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxSubarraySum</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span> arr) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> max_sum <span style=color:#f92672>=</span> INT_MIN, running_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> arr.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		running_sum <span style=color:#f92672>=</span> max(arr[i], running_sum <span style=color:#f92672>+</span> arr[i]);
</span></span><span style=display:flex><span>		max_sum <span style=color:#f92672>=</span> max(max_sum, running_sum);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> max_sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This makes it closer to the solution on Wikipedia.
Finally, I understand Kadane&rsquo;s algorithm.</p><h2 id=references>References</h2><ol><li><a href=https://en.wikipedia.org/wiki/Maximum_subarray_problem>https://en.wikipedia.org/wiki/Maximum_subarray_problem</a></li><li><a href=https://leetcode.com/problems/maximum-subarray/>https://leetcode.com/problems/maximum-subarray/</a></li></ol></content><p><a href=https://ttanay.github.io/tags/study/>#Study</a>
<a href=https://ttanay.github.io/tags/algorithms/>#Algorithms</a></p></main><footer></footer><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]}}</script></body></html>