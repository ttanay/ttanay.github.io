<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>How windowFunnel works in ClickHouse | Tanay Tummalapalli</title>
<meta name="title" content="How windowFunnel works in ClickHouse" />
<meta name="description" content="The windowFunnel function in ClickHouse has proved useful many times for me. I wondered how it actually works. I try to explain the algorithm it uses as well as why it works.
Background Funnels[1] are a type of visualization that track how many users progress through a set of steps. They are used to model customer journeys in different contexts like product, marketing, etc. Each step is visualized as a stage of a narrowing funnel." />
<meta name="keywords" content="algorithms,clickhouse,study," />


<meta property="og:url" content="https://ttanay.github.io/blog/window-funnel/">
  <meta property="og:site_name" content="Tanay Tummalapalli">
  <meta property="og:title" content="How windowFunnel works in ClickHouse">
  <meta property="og:description" content="The windowFunnel function in ClickHouse has proved useful many times for me. I wondered how it actually works. I try to explain the algorithm it uses as well as why it works.
Background Funnels[1] are a type of visualization that track how many users progress through a set of steps. They are used to model customer journeys in different contexts like product, marketing, etc. Each step is visualized as a stage of a narrowing funnel.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2024-06-12T13:06:55+05:30">
    <meta property="article:modified_time" content="2024-06-12T13:06:55+05:30">
    <meta property="article:tag" content="Algorithms">
    <meta property="article:tag" content="Clickhouse">
    <meta property="article:tag" content="Study">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="How windowFunnel works in ClickHouse">
  <meta name="twitter:description" content="The windowFunnel function in ClickHouse has proved useful many times for me. I wondered how it actually works. I try to explain the algorithm it uses as well as why it works.
Background Funnels[1] are a type of visualization that track how many users progress through a set of steps. They are used to model customer journeys in different contexts like product, marketing, etc. Each step is visualized as a stage of a narrowing funnel.">




  <meta itemprop="name" content="How windowFunnel works in ClickHouse">
  <meta itemprop="description" content="The windowFunnel function in ClickHouse has proved useful many times for me. I wondered how it actually works. I try to explain the algorithm it uses as well as why it works.
Background Funnels[1] are a type of visualization that track how many users progress through a set of steps. They are used to model customer journeys in different contexts like product, marketing, etc. Each step is visualized as a stage of a narrowing funnel.">
  <meta itemprop="datePublished" content="2024-06-12T13:06:55+05:30">
  <meta itemprop="dateModified" content="2024-06-12T13:06:55+05:30">
  <meta itemprop="wordCount" content="1179">
  <meta itemprop="keywords" content="Algorithms,Clickhouse,Study">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>

</head>

<body>
  <header><a href="/" class="title">
  <h2>Tanay Tummalapalli</h2>
</a>
<nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>How windowFunnel works in ClickHouse</h1>
<p>
  <i>
    <time datetime='2024-06-12' pubdate>
      12 Jun, 2024
    </time>
  </i>
</p>

<content>
  <p>The <code>windowFunnel</code> function in <a href="https://clickhouse.com/">ClickHouse</a> has proved useful many times for me. I wondered how it actually works. I try to explain the algorithm it uses as well as why it works.</p>
<h3 id="background">Background</h3>
<p><a href="https://en.wikipedia.org/wiki/Funnel_analysis">Funnels</a>[1] are a type of visualization that track how many users progress through a set of steps.
They are used to model customer journeys in different contexts like product, marketing, etc. Each step is visualized as a stage of a narrowing funnel. Hence, the name.</p>
<h2 id="problem">Problem</h2>
<p>Consider a dataset that contains the event stream of events performed by a user on a product.
The dataset contains the columns:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>user_id</code></td>
<td>The unique identifier for a user</td>
</tr>
<tr>
<td><code>event_name</code></td>
<td>The name of the event performed by the user. Eg: &ldquo;login&rdquo;, &ldquo;signup&rdquo;, &ldquo;add_to_cart&rdquo;, &ldquo;checkout&rdquo; etc.</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>The timestamp at which the action was performed(in epoch seconds).</td>
</tr>
</tbody>
</table>
<p>Say for a given user, the event stream contains events as rows with columns <code>[timestamp, event_name]</code>:</p>
<pre tabindex="0"><code>[
	[0, &#34;landing_page&#34;],
	[1, &#34;signup&#34;],
	[2, &#34;welcome&#34;],
	[3, &#34;product_page&#34;],
	[4, &#34;add_to_cart&#34;],
	[5, &#34;related&#34;],
	[6, &#34;product_page&#34;],
	[7, &#34;add_to_cart&#34;],
	[8, &#34;checkout&#34;]
]
</code></pre><p>How would we figure out a breakdown of users who signed up on the website, added an item to cart and then checked out for purchase all within an hour?</p>
<h3 id="formalizing-the-problem">Formalizing the problem</h3>
<p>To better understand the problem, let&rsquo;s express it more formally.</p>
<p>Let the events be described by a totally-ordered set \(E\) containing events \(e \in E\).
Let \(timestamp\) be a function that maps an event to its timestamp
</p>
$$timestamp(e): E \rightarrow \mathbb{Z}^{+}$$
<p>Let the type of an event be given by a totally-ordered finite set \(T\) where \(T \subset \mathbb{Z}^{+}\)
Let \(type\) be a function that maps an event in the event stream to its type.
</p>
$$type(e): E \rightarrow T$$
<p>
Let the event stream \(S\) be defined as a sequence drawn from \(E\), such that \( i \lt j \implies e_i \le e_j\) where \(i\) and \(j\) are the ordinal numbers of the sequence. The binary relation \(\le\) on \(E\) is defined as:
</p>
$$e_i \le e_j \iff (timestamp(e_i) \le timestamp(e_j)) \wedge (type(e_i) \le type(e_j))$$
<p>
We are given a sequence \(P\) drawn from the set \(T\) of length \(n\) that defines that pattern of events that the funnel should match.
We are given a window \(w\) that defines the maximum difference of the first and last timestamps of a funnel.</p>
<p>A funnel can be thought of as a function that evaluates the length of the maximum match found in the event stream \(S\) for a given pattern \(P\) and window \(w\).
Consider a sub-sequence \(m\) drawn from \(S\) &ndash; \(m = (e_1, &hellip;, e_i, &hellip;, e_k)\). The sequence \(m\) is said to be a match of \(P\) iff the following hold:</p>
<ol>
<li>\(type(e_i) = p_i\) where \(p_i\) is the \(i\)-th element of the sequence \(P\).</li>
<li>\(timestamp(e_k) - timestamp(e_1) \le w\) where \(1 \le k \le n\).</li>
</ol>
<p>Let \(M\) be the set of all possible matches such that \(m \in M\). Then, the level \(L\)  of a funnel is defined as the maximum length of all possible matches in \(M\).
</p>
$$L = max(|m| \mid m \in M) $$
<h2 id="solution">Solution</h2>
<p>We can break down the problem a bit to move towards a solution.
We need the following:</p>
<ol>
<li>Consider events of interest. Eg: <code>event_name IN (&quot;signup&quot;, &quot;add_to_cart&quot;, &quot;checkout&quot;)</code></li>
<li>Limit the timeframe/window. Eg: 1 hour in this case.</li>
<li>Consider the order of the events. Eg: <code>&quot;signup&quot; -&gt; &quot;add_to_cart&quot; -&gt; &quot;checkout&quot;</code></li>
</ol>
<p>The <code>windowFunnel</code> aggregate function does the job. For each user, it gives us the <code>level</code> up to which the user has converted.
It takes as input the following:</p>
<ol>
<li><code>window</code>: The timeframe/window in which the events should have been performed. It&rsquo;s unit is seconds.</li>
<li><code>timestamp</code> column: The column to be considered as the timestamp column.</li>
<li><code>condN</code>: The ordered conditions that make up the funnel. This makes up the pattern event chain.</li>
</ol>
<p>So, in our case, this query would give us the desired result:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> user_id,
</span></span><span style="display:flex;"><span>	windowFunnel(<span style="color:#ae81ff">3600</span>)(<span style="color:#66d9ef">timestamp</span>, event_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;signup&#39;</span>, event_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;add_to_cart&#39;</span>, event_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;checkout&#39;</span>) <span style="color:#66d9ef">AS</span> <span style="color:#66d9ef">level</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span>;
</span></span></code></pre></div><p>For a better example checkout the <a href="https://clickhouse.com/docs/en/sql-reference/aggregate-functions/parametric-functions#windowfunnel">documentation</a>[2].</p>
<p>It also supports three options - <code>strict_order</code>, <code>strict_deduplication</code>, and <code>strict_increase</code>. But, for this post, we will limit ourselves to the default algorithm.</p>
<h3 id="the-algorithm">The algorithm</h3>
<p>Now that we know what <a href="https://github.com/ClickHouse/ClickHouse/blob/abb88e4d607fb927e2d444a3f5b1928d5dc0b962/src/AggregateFunctions/AggregateFunctionWindowFunnel.cpp"><code>windowFunnel</code></a>[3] can do, let&rsquo;s open the black box to see what lies inside.
Although <code>windowFunnel</code> supports multiple options, if we look at the default behavior, the pseudocode looks something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> DateTime <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint64_t</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> EventIndex <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span>; <span style="color:#75715e">// The event index as defined by event chain
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span> windowFunnel(std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint64_t</span> window, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>DateTime, EventType<span style="color:#f92672">&gt;</span> data, std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span> events_chain_size) {
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>DateTime<span style="color:#f92672">&gt;&gt;</span> events_timestamp(events_chain_size);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> data.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">auto</span> [timestamp, event_idx] <span style="color:#f92672">=</span> data[i];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(event_idx <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			events_timestamp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> timestamp;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(events_timestamp[event_idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>].has_value() <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>			timestamp <span style="color:#f92672">&lt;=</span> events_timestamp[event_idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> window) {
</span></span><span style="display:flex;"><span>			events_timestamp[event_idx] <span style="color:#f92672">=</span> events_timestamp[event_idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(event_idx <span style="color:#f92672">==</span> events_chain_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> events_chain_size;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(size_t i <span style="color:#f92672">=</span> events_chain_size; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(events_timestamp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>].has_value())
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we don&rsquo;t bother with types, it would look something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">window_funnel</span>(window, data, events_chain_size):
</span></span><span style="display:flex;"><span>	events_timestamp <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> events_chain_size
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> data:
</span></span><span style="display:flex;"><span>		timestamp <span style="color:#f92672">=</span> row<span style="color:#f92672">.</span>timestamp
</span></span><span style="display:flex;"><span>		event_idx <span style="color:#f92672">=</span> row<span style="color:#f92672">.</span>event_idx
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> event_idx <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>			events_timestamp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> timestamp
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">elif</span> events_timestamp[event_idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> \
</span></span><span style="display:flex;"><span>			timestamp <span style="color:#f92672">&lt;=</span> events_timestamp[event_idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> window:
</span></span><span style="display:flex;"><span>			events_timestamp[event_idx] <span style="color:#f92672">=</span> events_timestamp[event_idx <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> event_idx <span style="color:#f92672">==</span> events_chain_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> events_chain_size
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(events_chain_size, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> events_timestamp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> i
</span></span></code></pre></div><p>Let&rsquo;s dig into why it works.</p>
<p><strong>Intuition</strong>: While scanning through the events list, we evaluate potential matches that can exist w.r.t the sliding window, tracking them in the <code>events_timestamp</code> array.</p>
<p>It maintains an array - <code>events_timestamp</code>, of the same size as the pattern that needs to be matched. This array stores the start timestamp of possible matches in the event stream. When evaluating a new event for the funnel, it checks the following:</p>
<ol>
<li>If it is the first event in the funnel&rsquo;s event pattern, a new window is opened by setting the <code>event_idx</code> of the <code>events_timestamp</code> array as the timestamp of the event.</li>
<li>For other events in the events chain, it checks if it has seen the predecessor event according to the funnel&rsquo;s event pattern. If it has seen its predecessor, it evaluates whether the event is within the defined the window by checking the difference of the start of the window stored in the <code>events_timestamp</code> of the predecessor event.
The <code>level</code> returned by the funnel is then evaluated using the index of the last non-empty value of the <code>events_timestamp</code> array.
In the <code>events_timestamp</code> array, it only keeps track of the timestamp of the start of the window because it relies on the fact that for an event for the same index of the funnel&rsquo;s pattern event chain, if there is an event with a higher timestamp, a successor event will be within the window even if evaluated w.r.t to the event with a higher timestamp.</li>
</ol>
<p>The time complexity for this algorithm is \(O(n)\). But, since the event stream needs to be sorted by <code>(event_timestamp, event_type)</code> first, it is bounded to \(O(n \log n)\).</p>
<h2 id="references">References</h2>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Funnel_analysis">https://en.wikipedia.org/wiki/Funnel_analysis</a></li>
<li><a href="https://clickhouse.com/docs/en/sql-reference/aggregate-functions/parametric-functions#windowfunnel">https://clickhouse.com/docs/en/sql-reference/aggregate-functions/parametric-functions#windowfunnel</a></li>
<li><a href="https://github.com/ClickHouse/ClickHouse/blob/abb88e4d607fb927e2d444a3f5b1928d5dc0b962/src/AggregateFunctions/AggregateFunctionWindowFunnel.cpp">https://github.com/ClickHouse/ClickHouse/blob/abb88e4d607fb927e2d444a3f5b1928d5dc0b962/src/AggregateFunctions/AggregateFunctionWindowFunnel.cpp</a></li>
<li><a href="https://www.jianshu.com/p/4c86a2478cca">https://www.jianshu.com/p/4c86a2478cca</a></li>
</ol>
<p>Thanks to Tushar and Srikanth for review!</p>

</content>
<p>
  
  <a href="https://ttanay.github.io/tags/algorithms/">#Algorithms</a>
  
  <a href="https://ttanay.github.io/tags/clickhouse/">#Clickhouse</a>
  
  <a href="https://ttanay.github.io/tags/study/">#Study</a>
  
</p>

  </main>
  <footer>
</footer>

  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    }
  };
</script>
</body>

</html>
